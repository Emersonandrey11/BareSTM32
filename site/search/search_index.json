{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bare Metal programming on STM32 Microcontrollers","text":""},{"location":"#motivation","title":"Motivation","text":"<p>There are a lot of tutorials on the internet about programming microcontrollers, but it's rare to see a local where all the information you need is at one place. So this page intends to organize and teach you everything you need to know about bare metal programming on a STM32 microcontroller board.</p>"},{"location":"#hardware","title":"Hardware","text":"<p>For information about our microcontroller board, please checkout the hardware page. In this page you will find schematics and PCB designs made with KiCAD. </p>"},{"location":"#gnu-arm-toolchain","title":"GNU ARM Toolchain","text":"<p>For information about compiling, debuggind and flashing code into the microcontroller, please checkout the Toolchain page. </p>"},{"location":"#stm32f030-architecture","title":"STM32F030 Architecture","text":"<p>For information and a tutorial about the STM32F030K6 microcontroller, please checkout the STM32F030 architecture page.</p>"},{"location":"#coding","title":"Coding","text":"<p>For information about the code, please checkout the code page.</p>"},{"location":"about/","title":"Author","text":"<p>Hi, my name is Emerson and you can contact me in these links:</p> <ul> <li>Linkedin</li> <li>Github</li> </ul>"},{"location":"about/#salve","title":"Salve","text":""},{"location":"code/","title":"Coding a MCU","text":"<p>The code should include:</p> <ol> <li>A basic GPIO library to toggle an LED on Pin 13</li> <li>Linker File</li> <li>Makefile</li> <li>Startup file</li> </ol> <p>The project structure is described as follows:</p> <ul> <li>The 'core' folder contains the 'inc' folder which are in essentially .h files </li> <li>The 'src' folder contains all the .c files (specially main.c)</li> </ul>"},{"location":"code/#basic-gpio-library","title":"Basic GPIO Library","text":"<p>In order to toggle an GPIO Pin, in ARM Cortex M0 microcontroller we need to:</p> <ol> <li>Define the memory location of the peripherals registers like RCC and GPIO</li> <li>Configure the needed registers</li> <li>Set the specifics bits</li> </ol>"},{"location":"hardware/","title":"Hardware design","text":"<p>The hardware is a basic microcontroller board which has only the necessary componentes to run it like:</p> <ul> <li>An LQFP32 STM32F030K6 microcontroller</li> <li>Header pins to access the microcontroller pins</li> <li>Reset button (connected directly to pin 4 - NRST)</li> <li>Pull-up/down switch connected on BOOT0 (Pin 31)</li> <li>User LED connected to PB1 (Pin 15)</li> <li>SWD header pin</li> </ul>"},{"location":"micro/","title":"Understanding our microcontroller","text":"<p>This page dives into the reference manual of STM32F030K6 and explains all the important information within the reference manual.</p>"},{"location":"micro/#system-architecture","title":"System architecture","text":"<p>In the figure below we can observe the system architecture. </p> <p></p> <p>As shown in the figure, the CPU access all the peripherals like ADC and SPI for example, via the APB bus which is connected to AHB1 bus. These busses are the clock connections between CPU and peripherals. So in order to read an ADC value, for example, first you need to activate the clock of ADC peripherals. If you don't activate, the CPU can't read the sampled values. You also need to configure the periphals register.</p>"},{"location":"micro/#memory-mapping","title":"Memory mapping","text":"<p>In the figure below we can observe the memory mapping. </p> <p></p>"},{"location":"micro/#code-section","title":"Code section","text":"<p>The code section in memory starts at address <code>0x0000 0000</code> and ends at address <code>0x2000 0000</code>. This sections includes memory address of Flash memory, system memory and bootconfiguration.</p> <ul> <li>From address <code>0x0000 0000</code> to <code>0x0004 0000</code> we have flash, system memory or SRAM.</li> <li>From address <code>0x0800 0000</code> to <code>0x0804 0000</code> we have the flash memory section</li> </ul>"},{"location":"micro/#sram-section","title":"SRAM section","text":"<ul> <li>From address <code>0x2000 0000</code> to <code>0x4000 0000</code> we have the SRAM section</li> </ul>"},{"location":"micro/#peripherals-section","title":"Peripherals section","text":"<ul> <li>From address <code>0x4000 0000</code> to <code>0x4000 8000</code> we have the memory section of APB registers. All the peripherals (ADCs, timers etc.) which are connected to APB registers can be configured simply by writing values inside these memory block. Information about the registers can be found into the APB Registers section.</li> </ul>"},{"location":"micro/#apb-registers","title":"APB Registers","text":"<p>dsl\u00e7kd\u00e7sld</p>"},{"location":"program/","title":"This section explains how to program and debug code to a microcontroller","text":""},{"location":"program/#serial-wire-debug-swd-protocol","title":"Serial wire debug - SWD Protocol","text":"<p>Using J4 (SWD header pin) we're gonna be able to programming our microcontroller board which means writing coding in our text editor and blinking and LED.</p> <p>TODO: Detailed the SWD protocol</p>"},{"location":"program/#gnu-arm-toolchain-arm-none-eabi","title":"GNU Arm Toolchain - arm-none-eabi","text":"<p>GNU Arm Toolchain is a set of tools used to compile, link, flash and degub code into hardware. Its a open-souce tool developed by its own community and it is one of the most toolchain used. This toolchain can de downloaded to GNU Arm Toolchain</p>"},{"location":"program/#compile-link-and-build","title":"Compile, Link and Build","text":""},{"location":"program/#compile","title":"Compile","text":"<p>The compiler, </p> <pre><code>\narm-none-eabi-gcc\n\n</code></pre> <p>first takes all .c files as an input and then outputs .i files. These .i files refers to a pre-processing file where all the directives (all the macros and stuff in .h files are check at this point) will be resolved. After that, from .i files, .s files are created.</p> <p>These files are responsable for convert the higher level language to mnemonics (assembly instructions). The mnemonics depends on microcontroler architeture.</p>"},{"location":"program/#assembler","title":"Assembler","text":"<p>In assemble stage, .s files are converted to .o files (relocatable object file - The instructions (opcodes) dont carries address only instructions). The .o files contains all the opcodes (which are symbols for instructions). After that, comes the linking stage.</p>"},{"location":"program/#linking","title":"Linking","text":"<p>An linker File (.ld) defines the memory layout for a specific microcontroller. A microcontroller memory includes sections like:</p> <ul> <li>FLASH (where the program and constant data stays)</li> <li>RAM (where the variable data stays, also stack[^1] and heap)</li> </ul> <p>So its the linkers file job to know the address for FLASH and RAM (and other peripherals).</p> <p>The linker file is used in the process of compiling and flashing a code into a microcontroller. In this process, the linker file maps these four differents files:</p> <ul> <li>.bss (contains vector table and uninitialized data)</li> <li>.data (initialized data)</li> <li>.rodata (read-only data and vector table)</li> <li>.text (executable code)</li> </ul>"},{"location":"program/#entry-point","title":"Entry point","text":"<p>The entry point defines the first instruction to be executed beeing usually:</p> <ul> <li>Reset handler in the startup code</li> </ul> <p>[^1]: What is a stack? Besides been a memory location.</p>"}]}